---
title: "Mini-Project 03 - Visualizing and Maintaining the Green Canopy of NYC"
execute: 
  cache: true
author: "katzap1018"
editor:
    mode: source
format:
    html:
        code-fold: true
---

## Introduction
New York City’s parks and trees have always felt like an essential part of the city to me—spaces that bring life, health, and character to our neighborhoods. As I work through this mini-project, I’m diving into the NYC TreeMap dataset to better understand how these green spaces are supported, maintained, and distributed across the city. My goal is to use data analysis and visualization to uncover insights about the role trees play in NYC’s urban fabric and, ultimately, to propose a program that helps ensure all New Yorkers can benefit from these natural resources.

```{r}
############################################################
# ---- Libraries ----
library(sf)
library(dplyr)
library(ggplot2)
library(httr2)

############################################################
# ---- Task 1: Download NYC City Council Districts ----
############################################################
get_nyc_council_districts <- function() {
    
    cat("Searching for council district shapefiles...\n")
    
    # All possible root directories where your files may live
    base_paths <- c(
        getwd(),
        file.path(getwd(), "data", "mp03"),
        file.path(getwd(), "data", "mp03", "citycouncildistricts"),
        file.path(Sys.getenv("USERPROFILE"), "OneDrive", "Documents", "STA9750-2025-FALL"),
        file.path(Sys.getenv("USERPROFILE"), "Documents", "STA9750-2025-FALL")
    )
    
    # Build list of directories to search
    possible_dirs <- c()
    for (base in base_paths) {
        possible_dirs <- c(possible_dirs,
                           file.path(base, "nycc_25c"),
                           file.path(base, "nyccwi_25c"),
                           file.path(base, "citycouncildistricts"),
                           file.path(base, "citycouncildistricts", "nycc_25c"),
                           file.path(base, "data", "mp03", "nycc_25c"),
                           file.path(base, "data", "mp03", "nyccwi_25c"),
                           file.path(base, "data", "mp03", "citycouncildistricts"),
                           file.path(base, "data", "mp03", "citycouncildistricts", "nycc_25c")
        )
    }
    
    shp_file <- NULL
    
    # Search each directory
    for (dir in possible_dirs) {
        if (dir.exists(dir)) {
            shp_candidates <- list.files(dir, pattern = "\\.shp$", full.names = TRUE)
            if (length(shp_candidates) > 0) {
                shp_file <- shp_candidates[1]
                cat("Found shapefile at:", shp_file, "\n")
                break
            }
        }
    }
    
    if (is.null(shp_file)) {
        cat("No council district shapefile found.\n")
        cat("Your working directory is:", getwd(), "\n")
        return(NULL)
    }
    
    # Read shapefile
    cat("Reading shapefile...\n")
    council <- sf::st_read(shp_file, quiet = TRUE)
    
    # Transform & simplify
    cat("Transforming CRS to WGS84...\n")
    council <- sf::st_transform(council, crs = "WGS84")
    
    cat("Simplifying geometry...\n")
    council <- council |> dplyr::mutate(geometry = st_simplify(geometry, dTolerance = 10))
    
    # Try to standardize district column name
    if (!"CounDist" %in% names(council)) {
        possible <- names(council)[grepl("dist|council|coundist|coun", names(council), ignore.case = TRUE)]
        if (length(possible) > 0) {
            names(council)[names(council) == possible[1]] <- "CounDist"
            cat("Renaming", possible[1], "→ CounDist\n")
        }
    }
    
    cat("✅ Successfully loaded", nrow(council), "districts.\n")
    return(council)
}


############################################################
# ---- Task 2: Download Tree Points
############################################################

download_tree_points <- function(limit = 50000L) {
  
  # Ensure directory exists
  dir_path <- "data/mp03"
  if (!dir.exists(dir_path)) dir.create(dir_path, recursive = TRUE)
  
  # Check for already-downloaded files
  existing_files <- list.files(
    dir_path, 
    pattern = "^treepoints_\\d{5}\\.geojson$",
    full.names = TRUE
  )
  
  # ---- SAFE MODE FOR RENDERING ----
  # If no local files exist AND we are in a non-interactive render, STOP.
  if (length(existing_files) == 0 && !interactive()) {
    stop(
      "\n No local Tree Points files found.\n",
      "Your system blocks downloads during Quarto rendering.\n",
      "➡ Run download_tree_points() manually in the Console first.\n",
      "This will create local copies like:\n",
      "  data/mp03/treepoints_00001.geojson\n",
      "Then Quarto will render successfully.\n"
    )
  }
  
  # ---- If files exist, just load them (safe for render) ----
  if (length(existing_files) > 0) {
    message("✔ Loading existing local Tree Points files...")
    
    tree_list <- lapply(existing_files, function(f) sf::st_read(f, quiet = TRUE))
    trees <- dplyr::bind_rows(tree_list)
    trees <- sf::st_transform(trees, crs = "WGS84")
    return(trees)
  }
  
  # ---- DOWNLOAD MODE (Console only) ----
  base_url <- "https://data.cityofnewyork.us/resource/nwxe-4ae8.geojson"
  
  offset <- 0L
  file_index <- 1L
  file_paths <- character()
  
  repeat {
    file_name <- sprintf("treepoints_%05d.geojson", file_index)
    file_path <- file.path(dir_path, file_name)
    
    message("⬇ Downloading page ", file_index, " ...")
    
    req <- httr2::request(base_url) |>
      httr2::req_url_query(`$limit` = limit, `$offset` = offset)
    
    resp <- httr2::req_perform(req)
    writeBin(httr2::resp_body_raw(resp), file_path)
    
    file_paths <- c(file_paths, file_path)
    
    # Inspect row count to detect last page
    this_sf <- sf::st_read(file_path, quiet = TRUE)
    n_rows  <- nrow(this_sf)
    
    message("   → Retrieved ", n_rows, " rows\n")
    
    if (n_rows < limit) break  # last page
    
    offset <- offset + limit
    file_index <- file_index + 1L
  }
  
  # Combine downloaded pages
  tree_list <- lapply(file_paths, function(f) sf::st_read(f, quiet = TRUE))
  trees <- dplyr::bind_rows(tree_list)
  trees <- sf::st_transform(trees, crs = "WGS84")
  
  message("✔ Finished downloading Tree Points.")
  return(trees)
}

```
```{r}
message=FALSE
# Load Council Districts safely
council <- get_nyc_council_districts()

# Load Tree Points from local files
trees <- download_tree_points()

############################################################
# ---- Task 3: Map All Trees Over Council Districts ----
############################################################

# Load council data
council <- get_nyc_council_districts()

# Load tree data
trees <- download_tree_points()

# FAST rendering mode
trees_for_plot <- dplyr::slice_sample(trees, n = 50000)

ggplot() +
  geom_sf(data = council, fill = NA, color = "grey60", linewidth = 0.3) +
  geom_sf(
    data = trees_for_plot,
    color = "darkgreen",
    alpha = 0.2,
    size = 0.05
  ) +
  labs(
    title = "NYC Street Trees Overlayed on Council Districts",
    subtitle = "Each point represents a tree from the NYC Street Tree Census",
    caption = "Data: NYC Open Data"
  ) +
  theme_minimal()


############################################################
# ---- Task 4: District-Level Analysis ----
############################################################

# Align CRS
trees   <- st_transform(trees, crs = "WGS84")
council <- st_transform(council, crs = "WGS84")

# Spatial join: trees inherit district attributes
trees_districts <- st_join(trees, council, join = st_within)

# Add district + borough columns
trees_districts <- trees_districts |>
  mutate(
    district = as.integer(CounDist),
    borough = case_when(
      district >= 1  & district <= 10 ~ "Manhattan",
      district >= 11 & district <= 18 ~ "Bronx",
      district >= 19 & district <= 32 ~ "Queens",
      district >= 33 & district <= 48 ~ "Brooklyn",
      district >= 49 & district <= 51 ~ "Staten Island",
      TRUE ~ NA_character_
    )
  )

# District summary
district_summary <- trees_districts |>
  st_drop_geometry() |>
  group_by(district) |>
  summarize(
    n_trees = n(),
    n_dead = sum(status == "Dead", na.rm = TRUE),
    frac_dead = n_dead / n_trees
  ) |>
  left_join(
    council |>
      st_drop_geometry() |>
      transmute(
        district = as.integer(CounDist),
        shape_area = Shape_Area
      ),
    by = "district"
  ) |>
  mutate(tree_density = n_trees / shape_area)


# ---- 4.1: Most Trees ----
most_trees <- district_summary |>
  arrange(desc(n_trees)) |>
  slice(1)

print(most_trees)

# ---- 4.2: Highest Tree Density ----
highest_density <- district_summary |>
  arrange(desc(tree_density)) |>
  slice(1)

print(highest_density)

# ---- 4.3: Highest Fraction Dead ----
highest_dead_fraction <- district_summary |>
  filter(n_trees > 0) |>
  arrange(desc(frac_dead)) |>
  slice(1)

print(highest_dead_fraction)

# ---- 4.4: Most Common Species in Manhattan ----
manhattan_species <- trees_districts |>
  filter(borough == "Manhattan") |>
  st_drop_geometry() |>
  count(spc_common, sort = TRUE)
most_common_species_manhattan <- manhattan_species$spc_common[[1]]
cat("The most common street tree species in Manhattan is:", most_common_species_manhattan)

print(head(manhattan_species, 10))


# ---- 4.5: Tree Closest to Baruch ----

new_st_point <- function(lat, lon){
  st_sfc(st_point(c(lon, lat)), crs = "WGS84")
}

baruch_point <- new_st_point(40.7403, -73.9833)

closest_tree <- trees |>
  mutate(distance = st_distance(geometry, baruch_point)) |>
  slice_min(distance, n = 1)

closest_species <- closest_tree$spc_common[[1]]

closest_species
```


############################################################
# ---- Task 5: Strengthening Midtown’s Green Canopy – A Targeted Tree Health and Replanting Program in City Council District 2
############################################################

New York City’s street trees are critical infrastructure: they cool sidewalks, reduce air pollution, absorb storm water, and make dense neighborhoods more livable. Yet the benefits of this urban forest are not evenly maintained over time. In City Council District 2, which includes much of Midtown East and the area around Baruch College, the Street Tree Census shows both a high overall tree count and meaningful pockets of aging or dead trees. This proposal requests targeted Parks Department funding for a tree health and replanting program in District 2.

District 2 ranks near the top of the city in total tree counts, but lagging behind several comparable districts in tree density per unit area and in the fraction of trees recorded as healthy. Our analysis, based on the NYC Street Tree Census and City Council district boundaries, identifies District 2 as having a relatively high number of dead trees and stumps. We propose a project scope of removing and replacing approximately dead or high-risk trees, grinding and replanting stumps, and planting new trees in under-served blocks, focusing on species that perform well in high-traffic, heat-prone environments.

A zoomed-in map of District 2, overlaid with tree points colored by condition (alive, dead, stump), makes these clusters visually apparent and allows field crews to identify priority segments quickly. A complementary bar chart comparing dead-tree fractions across District 2 and at least three similar districts (e.g., neighboring Manhattan districts) highlights that District 2 has both a substantial existing canopy and a higher-than-desired share of dead or missing trees. This framing supports the argument that investments here will both preserve an already valuable asset and address preventable decline.

Relative to other districts, District 2 combines high pedestrian volume, commercial density, and exposure to the urban heat island effect. Investing in tree health and replanting here will disproportionately benefit residents, students, small businesses, and commuters who rely on shaded sidewalks and cooler streets. By strategically replacing dead trees, replanting stumps, and filling gaps in low-canopy blocks, the Parks Department can significantly improve local environmental quality and demonstrate a model for proactive canopy maintenance in dense mixed-use districts. The proposed program is data-driven, tightly scoped, and aligned with citywide climate resilience goals, making District 2 a particularly strong candidate for additional tree-related funding.